{"version":3,"sources":["generators/generator.ts","generators/tscodegen.ts","generators/kotlincodegen.ts","parser.js","application.tsx","index.tsx"],"names":["generate","ast","generator","map","definition","start","startDefine","identifier","fields","processField","join","end","endDefine","concat","asFn","val","typemap","String","Long","Int","Short","Byte","Double","Float","Boolean","Array","field","genericType","generics","Map","tstype","primitive","type","nullable","TsCodegen","mutable","identity","kotlintype","KotlinCodegen","index","allFields","isLast","length","parser","peg$SyntaxError","message","expected","found","location","this","name","Error","captureStackTrace","child","parent","ctor","constructor","prototype","peg$subclass","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","text","class","i","escapedParts","parts","classEscape","inverted","any","other","description","hex","ch","charCodeAt","toString","toUpperCase","s","replace","j","descriptions","sort","slice","describeExpected","describeFound","SyntaxError","parse","input","options","peg$result","peg$FAILED","peg$startRuleFunctions","Definitions","peg$parseDefinitions","peg$startRuleFunction","peg$c0","peg$c1","peg$literalExpectation","peg$c2","definitions","filter","peg$c3","peg$c4","peg$c5","peg$c6","peg$c7","peg$c8","peg$c9","peg$classExpectation","peg$c10","comment","peg$c11","peg$c12","peg$c13","peg$c14","peg$c15","peg$c16","peg$c17","peg$c18","mutability","Object","objectSpread","peg$c19","peg$c20","peg$c21","peg$c22","peg$c23","peg$c24","peg$c25","peg$c26","peg$c27","peg$c28","peg$c29","type1","type2","peg$c30","peg$c31","peg$c32","peg$c33","peg$c34","peg$c35","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","peg$c48","peg$c49","peg$c50","peg$c51","peg$c52","peg$c53","peg$c54","peg$c55","peg$c56","peg$c57","peg$c58","peg$c59","peg$c60","peg$c61","peg$c62","peg$c63","peg$otherExpectation","peg$c64","peg$c65","peg$currPos","peg$savedPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","startRule","substring","ignoreCase","peg$computePosDetails","pos","p","details","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","offset","peg$fail","push","peg$buildStructuredError","s0","s1","s2","peg$parseDefinition","peg$parseComment","s3","s5","substr","peg$parse_","peg$parseIdentifier","s4","peg$parseField","peg$parseFields","test","charAt","s7","peg$parseFieldMutability","peg$parseFieldIdentifier","peg$parseTypes","peg$parsePrimitiveType","peg$parseArrayType","s9","peg$parseMapType","peg$parseReferenceType","peg$parseFieldNullability","testcase","Application","_useField","initialValue","_useState","useState","_useState2","slicedToArray","value","setValue","e","target","useField","_useField2","setDefinition","error","undefined","generateAst","tsCode","kotlinCode","react_default","a","createElement","className","htmlFor","id","onChange","JSON","stringify","readOnly","ReactDOM","render","src_application","document","getElementById"],"mappings":"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","file":"static/js/main.5fd13240.chunk.js","sourcesContent":["import { AST, Field } from '../ast';\n\nexport interface Generator {\n    startDefine(identifier: string): string;\n    endDefine(): string;\n    processField(field: Field, index: number, allFields: Field[]): string;\n}\n\nexport default function generate(ast: AST, generator: Generator): string {\n    return ast\n        .map((definition) => {\n            const start = generator.startDefine(definition.identifier);\n            const fields = definition.fields\n                .map(generator.processField)\n                .join('\\n');\n            const end = generator.endDefine();\n\n            return `${start}${fields}${end}`;\n        })\n        .join('');\n}\n","import { Generator } from './generator'\nimport { Field } from '../ast';\n\nfunction asFn<S>(val: S | (() => S)): () => S {\n    if (typeof val === 'function') {\n        return val as (() => S);\n    }\n    return () => val;\n}\n\nconst typemap: { [key: string]: (s: any) => string } = {\n    String: asFn('string'),\n    Long: asFn('number'),\n    Int: asFn('number'),\n    Short: asFn('number'),\n    Byte: asFn('number'),\n    Double: asFn('number'),\n    Float: asFn('number'),\n    Boolean: asFn('boolean'),\n    Array: (field: Field) => `Array<${genericType(field.generics[0])}>`,\n    Map: (field: Field) => `{ [ key: ${tstype(field.generics[0])} ]: ${genericType(field.generics[1])} }`\n};\n\nfunction tstype(field: Field): string {\n    return field.primitive ? typemap[field.type](field) : field.type;\n}\n\nfunction genericType(field: Field): string {\n    const type = field.primitive ? typemap[field.type](field) : field.type;\n    const nullable = field.nullable ? ' | null' : '';\n    return `${type}${nullable}`;\n}\n\nexport default class TsCodegen implements Generator {\n    startDefine(identifier: string): string {\n        return `export interface ${identifier} {\\n`;\n    }\n\n    endDefine(): string {\n        return '\\n}\\n\\n';\n    }\n\n    processField(field: Field): string {\n        return `    ${field.mutable ? '' : 'readonly '}${field.field}${field.nullable ? '?' : ''}: ${tstype(field)};`;\n    }\n}\n","import { Generator } from './generator'\nimport { Field } from '../ast';\n\nfunction identity(field: Field): string {\n    return field.type;\n}\n\nconst typemap: { [key: string]: (s: any) => string } = {\n    String: identity,\n    Long: identity,\n    Int: identity,\n    Short: identity,\n    Byte: identity,\n    Double: identity,\n    Float: identity,\n    Boolean: identity,\n    Array: (field: Field) => `List<${kotlintype(field.generics[0])}>`,\n    Map: (field: Field) => `Map<${kotlintype(field.generics[0])}, ${kotlintype(field.generics[1])}>`\n};\n\nfunction kotlintype(field: Field): string {\n    const type = field.primitive ? typemap[field.type](field) : field.type;\n    const nullable = field.nullable ? '?' : '';\n    return `${type}${nullable}`;\n}\n\n\nexport default class KotlinCodegen implements Generator {\n    startDefine(identifier: string): string {\n        return `data class ${identifier}(\\n`;\n    }\n\n    endDefine(): string {\n        return '\\n)\\n\\n';\n    }\n\n    processField(field: Field, index: number, allFields: Field[]): string {\n        const isLast = index === allFields.length - 1;\n        return `    ${field.mutable ? 'var' : 'val'} ${field.field}: ${kotlintype(field)}${isLast ? '' : ','}`;\n    }\n}\n","export default /*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n(function () {\n    \"use strict\";\n\n    function peg$subclass(child, parent) {\n        function ctor() {\n            this.constructor = child;\n        }\n\n        ctor.prototype = parent.prototype;\n        child.prototype = new ctor();\n    }\n\n    function peg$SyntaxError(message, expected, found, location) {\n        this.message = message;\n        this.expected = expected;\n        this.found = found;\n        this.location = location;\n        this.name = \"SyntaxError\";\n\n        if (typeof Error.captureStackTrace === \"function\") {\n            Error.captureStackTrace(this, peg$SyntaxError);\n        }\n    }\n\n    peg$subclass(peg$SyntaxError, Error);\n\n    peg$SyntaxError.buildMessage = function (expected, found) {\n        var DESCRIBE_EXPECTATION_FNS = {\n            literal: function (expectation) {\n                return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n            },\n\n            \"class\": function (expectation) {\n                var escapedParts = \"\",\n                    i;\n\n                for (i = 0; i < expectation.parts.length; i++) {\n                    escapedParts += expectation.parts[i] instanceof Array\n                        ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n                        : classEscape(expectation.parts[i]);\n                }\n\n                return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n            },\n\n            any: function (expectation) {\n                return \"any character\";\n            },\n\n            end: function (expectation) {\n                return \"end of input\";\n            },\n\n            other: function (expectation) {\n                return expectation.description;\n            }\n        };\n\n        function hex(ch) {\n            return ch.charCodeAt(0).toString(16).toUpperCase();\n        }\n\n        function literalEscape(s) {\n            return s\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\"/g, '\\\\\"')\n                .replace(/\\0/g, '\\\\0')\n                .replace(/\\t/g, '\\\\t')\n                .replace(/\\n/g, '\\\\n')\n                .replace(/\\r/g, '\\\\r')\n                .replace(/[\\x00-\\x0F]/g, function (ch) {\n                    return '\\\\x0' + hex(ch);\n                })\n                .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n                    return '\\\\x' + hex(ch);\n                });\n        }\n\n        function classEscape(s) {\n            return s\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\\]/g, '\\\\]')\n                .replace(/\\^/g, '\\\\^')\n                .replace(/-/g, '\\\\-')\n                .replace(/\\0/g, '\\\\0')\n                .replace(/\\t/g, '\\\\t')\n                .replace(/\\n/g, '\\\\n')\n                .replace(/\\r/g, '\\\\r')\n                .replace(/[\\x00-\\x0F]/g, function (ch) {\n                    return '\\\\x0' + hex(ch);\n                })\n                .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n                    return '\\\\x' + hex(ch);\n                });\n        }\n\n        function describeExpectation(expectation) {\n            return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n        }\n\n        function describeExpected(expected) {\n            var descriptions = new Array(expected.length),\n                i, j;\n\n            for (i = 0; i < expected.length; i++) {\n                descriptions[i] = describeExpectation(expected[i]);\n            }\n\n            descriptions.sort();\n\n            if (descriptions.length > 0) {\n                for (i = 1, j = 1; i < descriptions.length; i++) {\n                    if (descriptions[i - 1] !== descriptions[i]) {\n                        descriptions[j] = descriptions[i];\n                        j++;\n                    }\n                }\n                descriptions.length = j;\n            }\n\n            switch (descriptions.length) {\n                case 1:\n                    return descriptions[0];\n\n                case 2:\n                    return descriptions[0] + \" or \" + descriptions[1];\n\n                default:\n                    return descriptions.slice(0, -1).join(\", \")\n                        + \", or \"\n                        + descriptions[descriptions.length - 1];\n            }\n        }\n\n        function describeFound(found) {\n            return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n        }\n\n        return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n    };\n\n    function peg$parse(input, options) {\n        options = options !== void 0 ? options : {};\n\n        var peg$FAILED = {},\n\n            peg$startRuleFunctions = {Definitions: peg$parseDefinitions},\n            peg$startRuleFunction = peg$parseDefinitions,\n\n            peg$c0 = \"\\n\",\n            peg$c1 = peg$literalExpectation(\"\\n\", false),\n            peg$c2 = function (definitions) {\n                return definitions\n                    .filter((definition) => definition && (typeof definition !== 'string'));\n            },\n            peg$c3 = \"define\",\n            peg$c4 = peg$literalExpectation(\"define\", false),\n            peg$c5 = function (identifier, fields) {\n                return {\n                    identifier,\n                    fields\n                };\n            },\n            peg$c6 = \"//\",\n            peg$c7 = peg$literalExpectation(\"//\", false),\n            peg$c8 = /^[^\\n]/,\n            peg$c9 = peg$classExpectation([\"\\n\"], true, false),\n            peg$c10 = function (comment) {\n                return null;\n            },\n            peg$c11 = \"{\",\n            peg$c12 = peg$literalExpectation(\"{\", false),\n            peg$c13 = \"}\",\n            peg$c14 = peg$literalExpectation(\"}\", false),\n            peg$c15 = function (fields) {\n                return fields.filter((field) => field);\n            },\n            peg$c16 = \":\",\n            peg$c17 = peg$literalExpectation(\":\", false),\n            peg$c18 = function (mutability, field, type) {\n                return {field, ...type, ...mutability}\n            },\n            peg$c19 = function (type, nullable) {\n                return {...type, ...nullable};\n            },\n            peg$c20 = \"Array<\",\n            peg$c21 = peg$literalExpectation(\"Array<\", false),\n            peg$c22 = \">\",\n            peg$c23 = peg$literalExpectation(\">\", false),\n            peg$c24 = function (type) {\n                return {primitive: true, type: \"Array\", generics: [type]}\n            },\n            peg$c25 = \"Map<\",\n            peg$c26 = peg$literalExpectation(\"Map<\", false),\n            peg$c27 = \",\",\n            peg$c28 = peg$literalExpectation(\",\", false),\n            peg$c29 = function (type1, type2) {\n                return {primitive: true, type: \"Map\", generics: [type1, type2]}\n            },\n            peg$c30 = \"Long\",\n            peg$c31 = peg$literalExpectation(\"Long\", false),\n            peg$c32 = \"Int\",\n            peg$c33 = peg$literalExpectation(\"Int\", false),\n            peg$c34 = \"Short\",\n            peg$c35 = peg$literalExpectation(\"Short\", false),\n            peg$c36 = \"Byte\",\n            peg$c37 = peg$literalExpectation(\"Byte\", false),\n            peg$c38 = \"Double\",\n            peg$c39 = peg$literalExpectation(\"Double\", false),\n            peg$c40 = \"Float\",\n            peg$c41 = peg$literalExpectation(\"Float\", false),\n            peg$c42 = \"Boolean\",\n            peg$c43 = peg$literalExpectation(\"Boolean\", false),\n            peg$c44 = \"String\",\n            peg$c45 = peg$literalExpectation(\"String\", false),\n            peg$c46 = function () {\n                return {primitive: true, type: text(), generics: []};\n            },\n            peg$c47 = function (identifier) {\n                return {primitive: false, type: identifier, generics: []}\n            },\n            peg$c48 = \"var\",\n            peg$c49 = peg$literalExpectation(\"var\", false),\n            peg$c50 = \"val\",\n            peg$c51 = peg$literalExpectation(\"val\", false),\n            peg$c52 = function () {\n                return {mutable: text() === \"var\"}\n            },\n            peg$c53 = \"?\",\n            peg$c54 = peg$literalExpectation(\"?\", false),\n            peg$c55 = function (nullable) {\n                return {nullable: nullable == \"?\"};\n            },\n            peg$c56 = /^[_A-Za-z0-9]/,\n            peg$c57 = peg$classExpectation([\"_\", [\"A\", \"Z\"], [\"a\", \"z\"], [\"0\", \"9\"]], false, false),\n            peg$c58 = function () {\n                return text();\n            },\n            peg$c59 = /^[A-Z]/,\n            peg$c60 = peg$classExpectation([[\"A\", \"Z\"]], false, false),\n            peg$c61 = /^[a-z0-9]/,\n            peg$c62 = peg$classExpectation([[\"a\", \"z\"], [\"0\", \"9\"]], false, false),\n            peg$c63 = peg$otherExpectation(\"whitespace\"),\n            peg$c64 = /^[ \\t\\n\\r]/,\n            peg$c65 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false),\n\n            peg$currPos = 0,\n            peg$savedPos = 0,\n            peg$posDetailsCache = [{line: 1, column: 1}],\n            peg$maxFailPos = 0,\n            peg$maxFailExpected = [],\n            peg$silentFails = 0,\n\n            peg$result;\n\n        if (\"startRule\" in options) {\n            if (!(options.startRule in peg$startRuleFunctions)) {\n                throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n            }\n\n            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n        }\n\n        function text() {\n            return input.substring(peg$savedPos, peg$currPos);\n        }\n\n        function location() {\n            return peg$computeLocation(peg$savedPos, peg$currPos);\n        }\n\n        function expected(description, location) {\n            location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n            throw peg$buildStructuredError(\n                [peg$otherExpectation(description)],\n                input.substring(peg$savedPos, peg$currPos),\n                location\n            );\n        }\n\n        function error(message, location) {\n            location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n            throw peg$buildSimpleError(message, location);\n        }\n\n        function peg$literalExpectation(text, ignoreCase) {\n            return {type: \"literal\", text: text, ignoreCase: ignoreCase};\n        }\n\n        function peg$classExpectation(parts, inverted, ignoreCase) {\n            return {type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase};\n        }\n\n        function peg$anyExpectation() {\n            return {type: \"any\"};\n        }\n\n        function peg$endExpectation() {\n            return {type: \"end\"};\n        }\n\n        function peg$otherExpectation(description) {\n            return {type: \"other\", description: description};\n        }\n\n        function peg$computePosDetails(pos) {\n            var details = peg$posDetailsCache[pos], p;\n\n            if (details) {\n                return details;\n            } else {\n                p = pos - 1;\n                while (!peg$posDetailsCache[p]) {\n                    p--;\n                }\n\n                details = peg$posDetailsCache[p];\n                details = {\n                    line: details.line,\n                    column: details.column\n                };\n\n                while (p < pos) {\n                    if (input.charCodeAt(p) === 10) {\n                        details.line++;\n                        details.column = 1;\n                    } else {\n                        details.column++;\n                    }\n\n                    p++;\n                }\n\n                peg$posDetailsCache[pos] = details;\n                return details;\n            }\n        }\n\n        function peg$computeLocation(startPos, endPos) {\n            var startPosDetails = peg$computePosDetails(startPos),\n                endPosDetails = peg$computePosDetails(endPos);\n\n            return {\n                start: {\n                    offset: startPos,\n                    line: startPosDetails.line,\n                    column: startPosDetails.column\n                },\n                end: {\n                    offset: endPos,\n                    line: endPosDetails.line,\n                    column: endPosDetails.column\n                }\n            };\n        }\n\n        function peg$fail(expected) {\n            if (peg$currPos < peg$maxFailPos) {\n                return;\n            }\n\n            if (peg$currPos > peg$maxFailPos) {\n                peg$maxFailPos = peg$currPos;\n                peg$maxFailExpected = [];\n            }\n\n            peg$maxFailExpected.push(expected);\n        }\n\n        function peg$buildSimpleError(message, location) {\n            return new peg$SyntaxError(message, null, null, location);\n        }\n\n        function peg$buildStructuredError(expected, found, location) {\n            return new peg$SyntaxError(\n                peg$SyntaxError.buildMessage(expected, found),\n                expected,\n                found,\n                location\n            );\n        }\n\n        function peg$parseDefinitions() {\n            var s0, s1, s2;\n\n            s0 = peg$currPos;\n            s1 = [];\n            s2 = peg$parseDefinition();\n            if (s2 === peg$FAILED) {\n                s2 = peg$parseComment();\n                if (s2 === peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 10) {\n                        s2 = peg$c0;\n                        peg$currPos++;\n                    } else {\n                        s2 = peg$FAILED;\n                        if (peg$silentFails === 0) {\n                            peg$fail(peg$c1);\n                        }\n                    }\n                }\n            }\n            while (s2 !== peg$FAILED) {\n                s1.push(s2);\n                s2 = peg$parseDefinition();\n                if (s2 === peg$FAILED) {\n                    s2 = peg$parseComment();\n                    if (s2 === peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 10) {\n                            s2 = peg$c0;\n                            peg$currPos++;\n                        } else {\n                            s2 = peg$FAILED;\n                            if (peg$silentFails === 0) {\n                                peg$fail(peg$c1);\n                            }\n                        }\n                    }\n                }\n            }\n            if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c2(s1);\n            }\n            s0 = s1;\n\n            return s0;\n        }\n\n        function peg$parseDefinition() {\n            var s0, s1, s2, s3, s4, s5;\n\n            s0 = peg$currPos;\n            if (input.substr(peg$currPos, 6) === peg$c3) {\n                s1 = peg$c3;\n                peg$currPos += 6;\n            } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c4);\n                }\n            }\n            if (s1 !== peg$FAILED) {\n                s2 = peg$parse_();\n                if (s2 !== peg$FAILED) {\n                    s3 = peg$parseIdentifier();\n                    if (s3 !== peg$FAILED) {\n                        s4 = peg$parse_();\n                        if (s4 !== peg$FAILED) {\n                            s5 = peg$parseFields();\n                            if (s5 !== peg$FAILED) {\n                                peg$savedPos = s0;\n                                s1 = peg$c5(s3, s5);\n                                s0 = s1;\n                            } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                            }\n                        } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                        }\n                    } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n\n            return s0;\n        }\n\n        function peg$parseComment() {\n            var s0, s1, s2, s3;\n\n            s0 = peg$currPos;\n            if (input.substr(peg$currPos, 2) === peg$c6) {\n                s1 = peg$c6;\n                peg$currPos += 2;\n            } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c7);\n                }\n            }\n            if (s1 !== peg$FAILED) {\n                s2 = [];\n                if (peg$c8.test(input.charAt(peg$currPos))) {\n                    s3 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                } else {\n                    s3 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                        peg$fail(peg$c9);\n                    }\n                }\n                if (s3 !== peg$FAILED) {\n                    while (s3 !== peg$FAILED) {\n                        s2.push(s3);\n                        if (peg$c8.test(input.charAt(peg$currPos))) {\n                            s3 = input.charAt(peg$currPos);\n                            peg$currPos++;\n                        } else {\n                            s3 = peg$FAILED;\n                            if (peg$silentFails === 0) {\n                                peg$fail(peg$c9);\n                            }\n                        }\n                    }\n                } else {\n                    s2 = peg$FAILED;\n                }\n                if (s2 !== peg$FAILED) {\n                    s3 = peg$parse_();\n                    if (s3 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c10(s2);\n                        s0 = s1;\n                    } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n\n            return s0;\n        }\n\n        function peg$parseFields() {\n            var s0, s1, s2, s3, s4, s5;\n\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 123) {\n                s1 = peg$c11;\n                peg$currPos++;\n            } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c12);\n                }\n            }\n            if (s1 !== peg$FAILED) {\n                s2 = peg$parse_();\n                if (s2 !== peg$FAILED) {\n                    s3 = [];\n                    s4 = peg$parseField();\n                    if (s4 === peg$FAILED) {\n                        s4 = peg$parseComment();\n                    }\n                    while (s4 !== peg$FAILED) {\n                        s3.push(s4);\n                        s4 = peg$parseField();\n                        if (s4 === peg$FAILED) {\n                            s4 = peg$parseComment();\n                        }\n                    }\n                    if (s3 !== peg$FAILED) {\n                        s4 = peg$parse_();\n                        if (s4 !== peg$FAILED) {\n                            if (input.charCodeAt(peg$currPos) === 125) {\n                                s5 = peg$c13;\n                                peg$currPos++;\n                            } else {\n                                s5 = peg$FAILED;\n                                if (peg$silentFails === 0) {\n                                    peg$fail(peg$c14);\n                                }\n                            }\n                            if (s5 !== peg$FAILED) {\n                                peg$savedPos = s0;\n                                s1 = peg$c15(s3);\n                                s0 = s1;\n                            } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                            }\n                        } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                        }\n                    } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n\n            return s0;\n        }\n\n        function peg$parseField() {\n            var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n            s0 = peg$currPos;\n            s1 = peg$parseFieldMutability();\n            if (s1 !== peg$FAILED) {\n                s2 = peg$parse_();\n                if (s2 !== peg$FAILED) {\n                    s3 = peg$parseFieldIdentifier();\n                    if (s3 !== peg$FAILED) {\n                        s4 = peg$parse_();\n                        if (s4 !== peg$FAILED) {\n                            if (input.charCodeAt(peg$currPos) === 58) {\n                                s5 = peg$c16;\n                                peg$currPos++;\n                            } else {\n                                s5 = peg$FAILED;\n                                if (peg$silentFails === 0) {\n                                    peg$fail(peg$c17);\n                                }\n                            }\n                            if (s5 !== peg$FAILED) {\n                                s6 = peg$parse_();\n                                if (s6 !== peg$FAILED) {\n                                    s7 = peg$parseTypes();\n                                    if (s7 !== peg$FAILED) {\n                                        s8 = peg$parse_();\n                                        if (s8 !== peg$FAILED) {\n                                            peg$savedPos = s0;\n                                            s1 = peg$c18(s1, s3, s7);\n                                            s0 = s1;\n                                        } else {\n                                            peg$currPos = s0;\n                                            s0 = peg$FAILED;\n                                        }\n                                    } else {\n                                        peg$currPos = s0;\n                                        s0 = peg$FAILED;\n                                    }\n                                } else {\n                                    peg$currPos = s0;\n                                    s0 = peg$FAILED;\n                                }\n                            } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                            }\n                        } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                        }\n                    } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n\n            return s0;\n        }\n\n        function peg$parseTypes() {\n            var s0, s1, s2;\n\n            s0 = peg$currPos;\n            s1 = peg$parsePrimitiveType();\n            if (s1 === peg$FAILED) {\n                s1 = peg$parseArrayType();\n                if (s1 === peg$FAILED) {\n                    s1 = peg$parseMapType();\n                    if (s1 === peg$FAILED) {\n                        s1 = peg$parseReferenceType();\n                    }\n                }\n            }\n            if (s1 !== peg$FAILED) {\n                s2 = peg$parseFieldNullability();\n                if (s2 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c19(s1, s2);\n                    s0 = s1;\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n\n            return s0;\n        }\n\n        function peg$parseArrayType() {\n            var s0, s1, s2, s3;\n\n            s0 = peg$currPos;\n            if (input.substr(peg$currPos, 6) === peg$c20) {\n                s1 = peg$c20;\n                peg$currPos += 6;\n            } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c21);\n                }\n            }\n            if (s1 !== peg$FAILED) {\n                s2 = peg$parseTypes();\n                if (s2 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 62) {\n                        s3 = peg$c22;\n                        peg$currPos++;\n                    } else {\n                        s3 = peg$FAILED;\n                        if (peg$silentFails === 0) {\n                            peg$fail(peg$c23);\n                        }\n                    }\n                    if (s3 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c24(s2);\n                        s0 = s1;\n                    } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n\n            return s0;\n        }\n\n        function peg$parseMapType() {\n            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n            s0 = peg$currPos;\n            if (input.substr(peg$currPos, 4) === peg$c25) {\n                s1 = peg$c25;\n                peg$currPos += 4;\n            } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c26);\n                }\n            }\n            if (s1 !== peg$FAILED) {\n                s2 = peg$parse_();\n                if (s2 !== peg$FAILED) {\n                    s3 = peg$parseTypes();\n                    if (s3 !== peg$FAILED) {\n                        s4 = peg$parse_();\n                        if (s4 !== peg$FAILED) {\n                            if (input.charCodeAt(peg$currPos) === 44) {\n                                s5 = peg$c27;\n                                peg$currPos++;\n                            } else {\n                                s5 = peg$FAILED;\n                                if (peg$silentFails === 0) {\n                                    peg$fail(peg$c28);\n                                }\n                            }\n                            if (s5 !== peg$FAILED) {\n                                s6 = peg$parse_();\n                                if (s6 !== peg$FAILED) {\n                                    s7 = peg$parseTypes();\n                                    if (s7 !== peg$FAILED) {\n                                        s8 = peg$parse_();\n                                        if (s8 !== peg$FAILED) {\n                                            if (input.charCodeAt(peg$currPos) === 62) {\n                                                s9 = peg$c22;\n                                                peg$currPos++;\n                                            } else {\n                                                s9 = peg$FAILED;\n                                                if (peg$silentFails === 0) {\n                                                    peg$fail(peg$c23);\n                                                }\n                                            }\n                                            if (s9 !== peg$FAILED) {\n                                                peg$savedPos = s0;\n                                                s1 = peg$c29(s3, s7);\n                                                s0 = s1;\n                                            } else {\n                                                peg$currPos = s0;\n                                                s0 = peg$FAILED;\n                                            }\n                                        } else {\n                                            peg$currPos = s0;\n                                            s0 = peg$FAILED;\n                                        }\n                                    } else {\n                                        peg$currPos = s0;\n                                        s0 = peg$FAILED;\n                                    }\n                                } else {\n                                    peg$currPos = s0;\n                                    s0 = peg$FAILED;\n                                }\n                            } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                            }\n                        } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                        }\n                    } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n\n            return s0;\n        }\n\n        function peg$parsePrimitiveType() {\n            var s0, s1;\n\n            s0 = peg$currPos;\n            if (input.substr(peg$currPos, 4) === peg$c30) {\n                s1 = peg$c30;\n                peg$currPos += 4;\n            } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c31);\n                }\n            }\n            if (s1 === peg$FAILED) {\n                if (input.substr(peg$currPos, 3) === peg$c32) {\n                    s1 = peg$c32;\n                    peg$currPos += 3;\n                } else {\n                    s1 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                        peg$fail(peg$c33);\n                    }\n                }\n                if (s1 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 5) === peg$c34) {\n                        s1 = peg$c34;\n                        peg$currPos += 5;\n                    } else {\n                        s1 = peg$FAILED;\n                        if (peg$silentFails === 0) {\n                            peg$fail(peg$c35);\n                        }\n                    }\n                    if (s1 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 4) === peg$c36) {\n                            s1 = peg$c36;\n                            peg$currPos += 4;\n                        } else {\n                            s1 = peg$FAILED;\n                            if (peg$silentFails === 0) {\n                                peg$fail(peg$c37);\n                            }\n                        }\n                        if (s1 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 6) === peg$c38) {\n                                s1 = peg$c38;\n                                peg$currPos += 6;\n                            } else {\n                                s1 = peg$FAILED;\n                                if (peg$silentFails === 0) {\n                                    peg$fail(peg$c39);\n                                }\n                            }\n                            if (s1 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 5) === peg$c40) {\n                                    s1 = peg$c40;\n                                    peg$currPos += 5;\n                                } else {\n                                    s1 = peg$FAILED;\n                                    if (peg$silentFails === 0) {\n                                        peg$fail(peg$c41);\n                                    }\n                                }\n                                if (s1 === peg$FAILED) {\n                                    if (input.substr(peg$currPos, 7) === peg$c42) {\n                                        s1 = peg$c42;\n                                        peg$currPos += 7;\n                                    } else {\n                                        s1 = peg$FAILED;\n                                        if (peg$silentFails === 0) {\n                                            peg$fail(peg$c43);\n                                        }\n                                    }\n                                    if (s1 === peg$FAILED) {\n                                        if (input.substr(peg$currPos, 6) === peg$c44) {\n                                            s1 = peg$c44;\n                                            peg$currPos += 6;\n                                        } else {\n                                            s1 = peg$FAILED;\n                                            if (peg$silentFails === 0) {\n                                                peg$fail(peg$c45);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c46();\n            }\n            s0 = s1;\n\n            return s0;\n        }\n\n        function peg$parseReferenceType() {\n            var s0, s1;\n\n            s0 = peg$currPos;\n            s1 = peg$parseIdentifier();\n            if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c47(s1);\n            }\n            s0 = s1;\n\n            return s0;\n        }\n\n        function peg$parseFieldMutability() {\n            var s0, s1;\n\n            s0 = peg$currPos;\n            if (input.substr(peg$currPos, 3) === peg$c48) {\n                s1 = peg$c48;\n                peg$currPos += 3;\n            } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c49);\n                }\n            }\n            if (s1 === peg$FAILED) {\n                if (input.substr(peg$currPos, 3) === peg$c50) {\n                    s1 = peg$c50;\n                    peg$currPos += 3;\n                } else {\n                    s1 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                        peg$fail(peg$c51);\n                    }\n                }\n            }\n            if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c52();\n            }\n            s0 = s1;\n\n            return s0;\n        }\n\n        function peg$parseFieldNullability() {\n            var s0, s1;\n\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 63) {\n                s1 = peg$c53;\n                peg$currPos++;\n            } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c54);\n                }\n            }\n            if (s1 === peg$FAILED) {\n                s1 = null;\n            }\n            if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c55(s1);\n            }\n            s0 = s1;\n\n            return s0;\n        }\n\n        function peg$parseFieldIdentifier() {\n            var s0, s1, s2;\n\n            s0 = peg$currPos;\n            s1 = [];\n            if (peg$c56.test(input.charAt(peg$currPos))) {\n                s2 = input.charAt(peg$currPos);\n                peg$currPos++;\n            } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c57);\n                }\n            }\n            if (s2 !== peg$FAILED) {\n                while (s2 !== peg$FAILED) {\n                    s1.push(s2);\n                    if (peg$c56.test(input.charAt(peg$currPos))) {\n                        s2 = input.charAt(peg$currPos);\n                        peg$currPos++;\n                    } else {\n                        s2 = peg$FAILED;\n                        if (peg$silentFails === 0) {\n                            peg$fail(peg$c57);\n                        }\n                    }\n                }\n            } else {\n                s1 = peg$FAILED;\n            }\n            if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c58();\n            }\n            s0 = s1;\n\n            return s0;\n        }\n\n        function peg$parseIdentifier() {\n            var s0, s1, s2, s3;\n\n            s0 = peg$currPos;\n            if (peg$c59.test(input.charAt(peg$currPos))) {\n                s1 = input.charAt(peg$currPos);\n                peg$currPos++;\n            } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c60);\n                }\n            }\n            if (s1 !== peg$FAILED) {\n                s2 = [];\n                if (peg$c61.test(input.charAt(peg$currPos))) {\n                    s3 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                } else {\n                    s3 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                        peg$fail(peg$c62);\n                    }\n                }\n                while (s3 !== peg$FAILED) {\n                    s2.push(s3);\n                    if (peg$c61.test(input.charAt(peg$currPos))) {\n                        s3 = input.charAt(peg$currPos);\n                        peg$currPos++;\n                    } else {\n                        s3 = peg$FAILED;\n                        if (peg$silentFails === 0) {\n                            peg$fail(peg$c62);\n                        }\n                    }\n                }\n                if (s2 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c58();\n                    s0 = s1;\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n\n            return s0;\n        }\n\n        function peg$parse_() {\n            var s0, s1;\n\n            peg$silentFails++;\n            s0 = [];\n            if (peg$c64.test(input.charAt(peg$currPos))) {\n                s1 = input.charAt(peg$currPos);\n                peg$currPos++;\n            } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c65);\n                }\n            }\n            while (s1 !== peg$FAILED) {\n                s0.push(s1);\n                if (peg$c64.test(input.charAt(peg$currPos))) {\n                    s1 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                } else {\n                    s1 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                        peg$fail(peg$c65);\n                    }\n                }\n            }\n            peg$silentFails--;\n            if (s0 === peg$FAILED) {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                    peg$fail(peg$c63);\n                }\n            }\n\n            return s0;\n        }\n\n        peg$result = peg$startRuleFunction();\n\n        if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n            return peg$result;\n        } else {\n            if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n                peg$fail(peg$endExpectation());\n            }\n\n            throw peg$buildStructuredError(\n                peg$maxFailExpected,\n                peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n                peg$maxFailPos < input.length\n                    ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n                    : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n            );\n        }\n    }\n\n    return {\n        SyntaxError: peg$SyntaxError,\n        parse: peg$parse\n    };\n})();\n","import React, { useState } from 'react';\nimport { AST } from './ast';\nimport generate from './generators/generator';\nimport TsCodegen from './generators/tscodegen';\nimport KotlinCodegen from './generators/kotlincodegen';\nimport parser from './parser';\nimport './application.css';\n\nfunction useField<S extends string>(initialValue: S): [S, React.ChangeEventHandler<any>] {\n    const [value, setValue] = useState<S>(initialValue);\n    const onChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => setValue(e.target.value as S);\n\n    return [value, onChange];\n}\n\nfunction generateAst(value: string): { ast: AST, error?: string } {\n    try {\n        return { ast: parser.parse(value), error: undefined };\n    } catch (e) {\n        return { ast: [], error: e.message }\n    }\n}\n\nfunction generateCode(value: string) {\n    return value;\n}\n\nconst testcase = `define Deep {\n  var maps: Map<Int, Map<Int, Map<Int, Deep>>>\n  val lists: Array<Array<Array<Deep>>>\n  val lists: Array<Array<Array<Deep>>>\n}\n\ndefine Kunde {\n  val id: String?\n  val navn: String\n  var kontoer: Array<Konto?>?\n  val bekjente: Map<String?, Kunde?>\n}\n\ndefine Konto {\n  val id: String\n  val kroner: Int\n  val ore: Int\n}`;\n\nfunction Application() {\n    const [definition, setDefinition] = useField(testcase);\n    const ast = generateAst(definition);\n    const tsCode = generate(ast.ast, new TsCodegen());\n    const kotlinCode = generate(ast.ast, new KotlinCodegen());\n\n    return (\n        <div className=\"application\">\n            <div className=\"editor\">\n                <div className=\"editor__textarea editor__definition\">\n                    <label htmlFor=\"definitiontxt\">Definition</label>\n                    <textarea id=\"definitiontxt\" value={definition} onChange={setDefinition}/>\n                </div>\n                <div className=\"editor__textarea editor__ast\">\n                    <label htmlFor=\"asttxt\">AST</label>\n                    <textarea id=\"asttxt\" value={JSON.stringify(ast.ast, null, 2)} readOnly/>\n                </div>\n                <div className=\"editor__textarea editor__code\">\n                    <label htmlFor=\"codetxt\">Code</label>\n                    <textarea id=\"codetxt\" value={tsCode} readOnly/>\n                </div>\n                <div className=\"editor__textarea editor__code\">\n                    <label htmlFor=\"codetxt\">Code</label>\n                    <textarea id=\"codetxt\" value={kotlinCode} readOnly/>\n                </div>\n            </div>\n            <div className=\"feedback\">\n                {ast.error}\n            </div>\n        </div>\n    );\n}\n\nexport default Application;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Application from './application';\n\nReactDOM.render(<Application />, document.getElementById('root'));\n"],"sourceRoot":""}